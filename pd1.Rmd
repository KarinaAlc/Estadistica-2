---
title: "Pr√°ctica dirigida 1"
output: 
  html_document:
    toc: yes
    toc_float: yes
    collapsed: no
    number_sections: no
    toc_depth: 1
    theme: simplex
    highlight: kate
    always_allow_html: true
    code_folding: show
---

## FACULTAD DE CIENCIAS SOCIALES - PUCP <br>

# **Tidyverse y RL**
<br>
<center><img src=" " width="200"/></center>

```{r,include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

```{r,echo=FALSE, out.width="30%"}
knitr::include_graphics("logoPUCP.png") 
```


### Jefas de Pr√°ctica: Karina Alc√°ntara üë©‚Äçüè´  y Lizette Crisp√≠n üë©‚Äçüè´<br>

### **SESI√ìN 1 - Tidyverse y RL** <br>

============================================================

### **MUNDO TIDYVERSE**

```{r,echo=FALSE, out.width="30%",fig.align = "center"}
knitr::include_graphics("pd1_tidy.png") 
```

Tidyverse es un conjunto de de paquetes de R para ciencia de datos, nos
ayuda a trabajar las bases de datos. Ha sido desarrollado por RStudio.

-   **Es consistente** : Todos los paquetes tienen una misma estructura

-   **Concatenable**: Siempre se pueden unir peque√±as partes para
    resolverlos

-   **Funcional**: Como casi todo R, promueve la programaci√≥n

Para cada paso de tratamiento de datos existe un paquete, se puede pasar
desde cargar/importar los datos, limpiarlos, transformarlos, visualizar,
modelarlos y finalmente comunicarlos.

Para importar datos tenemos readr, haven y readxl. Para limpiar los
datos usamos *tidyr*, para transofrmar los datos se usa dyplr, que lo
veremos a continuaci√≥n, para modelar se usa purr o broom, para
visualizar se usa ggplot2. Finalmente, para comunicar se usa knitr para
publicar los resultados por html, pdf, ppt. y rmarkdown es la estructura
de knitr.

Algunos les gusta usarlo porque facilita el an√°lisis y manipulaci√≥n de
datos y es m√°s r√°pido, pero, por otro lado, tiene otra l√≥gica en la
programaci√≥n. En vez de usar "," para diferenciar entre comandos, usar
%\>%,

Instalando el paquete de tidyverse te incluye los 8 paquetes. Pero, eso
s√≠, toma m√°s tiempo de lo debido. Por eso, en esta ocasi√≥n, se ha
descargado los que necesitaremos ahora

```{r}
#  Paquetes que se usar√°n #
library(dplyr)
library(ggplot2)
library(data.table)
library(devtools)
library(foreign)
library(rio)
```

#### Importar y preparar base de datos

```{r, results = 'hide',  fig.show='hide'}

usa <- read.spss("usa.sav",
          use.value.labels = T, 
          to.data.frame=TRUE)
str(usa)#Ver estructura de bases de datos, tipo de variable
#View(usa) #Ver base de datos 
```

PAQUETE DPLYR

El paquete dplyr es el m√°s √∫til en R para la manipulaci√≥n de datos, una
de las ventajas es que se pueda usar el pipe para combinar diferentes
funciones en R. Para no tener que escribirlo, se genera mediante control
shift M. En pocas palabras, reemplaza la "," para concatenar(unir)
varios comandos.

### **FILTER**: filtrar filas seg√∫n un criterio

Filtra casos o filas que cumplen con el criterio. Por ejemplo, aca
estamos filtrando de la data usa las personas que son jud√≠os

```{r, results = 'hide',  fig.show='hide'}
filter(usa, relig=="Judio", intecamp=="1. Mucho") 

filter(usa, edad >= 50)

filter(usa, intecamp=="1. Mucho", sexo=="Hombre", consipol=="1. Muy liberal")

filter(usa, intecamp=="1. Mucho", sexo=="Mujer", consipol=="7. Muy Conservador")
```

### **SELECT**: Seleccionando subconjunto de variables

Selecciona columnas o mejor dicho, variables de su conjunto de datos,
seg√∫n nombre.

En este comando estamos especificando que queremos seleccionar de la
data usa, las variables inter√©s en las campa√±as (intecamp) y sexo.

```{r, results = 'hide',  fig.show='hide'}
inte<-select(usa, intecamp, sexo)
inte
```

Si queremos quitar variable ponemos el signo de menos. Salen todas las
varibales menos las del si voto en las elecciones del 96 (voto96) y por
qui√©n.

Lo podr√≠amos volver un objeto para poder trabajar con ello

```{r, results = 'hide',  fig.show='hide'}
# quitando variables
select(usa, -voto96, -quien96)
menos96 <- select(usa, -voto96, -quien96)
menos96 
```

### **SUMMARISE**: Crear resumenes de datos

Resume cualquiera de las funciones anteriores, para aplicarla a un grupo
de datos.

En este caso, queremos sacar el promedio de aprobaci√≥n de Al Gore luego
de su gesti√≥n. Para eso usamos sumarise. Mencionamos los datos de la
base usa, luego la variable que se crear√° en base a ella, que ser√° la
media de la variable gorepst, omitiendo los valores perdidos

Solo con variables num√©ricas (ojo)

```{r, results = 'hide',  fig.show='hide'}
#Promedio aprobaci√≥n Al Gore post elecciones
summarise(usa, promgorepost = mean(gorepst, na.rm = T))
#CORROBORAMOS
class(usa$gorepst) 

```

Ac√° nos menciona un error, dice que el argumento no es num√©rico. Las
convertimos

```{r, results = 'hide',  fig.show='hide'}
#CORREGIMOS
usa$gorepst<- as.numeric(usa$gorepst)
usa$gorepre<- as.numeric(usa$gorepre)

summarise(usa, promgorepost = mean(gorepst, na.rm = T))
```

### **COUNT**: contar casos en base a una variable

Nos ayuda a contar las observaciones.

Vamos a contar los casos de las personas de acuerdo al nivel educativo.

Se puede observar que la mayor√≠a tiene un nivel educativo mayor al de
secundaria.

```{r, results = 'hide',  fig.show='hide'}
count(usa, relig)
count(usa, educ, sort = F) #numero de personas en base a nivel educativo, con SORT=T estamos diciendo que nos ordene los datos de manera descendente

```

### **MUTATE Y ARRANGE**

Crea nuevas columnas conservando las variables existentes. En esta
ocasi√≥n estamos creando una nueva variable que vendr√≠a a ser la
diferencia de la aprobaci√≥n de Al Gore antes y luego de su gesti√≥n.

Esta funci√≥n es un poco m√°s larga, pero no es dif√≠cil. Primero crearemos
una nueva variable que ser√° la diferencia de la aprobaci√≥n de Al Gore
antes y luego de su gesti√≥n, y luego de eso, queremos que esa variable
creada, se ordene de manera descendente. Finalmente, queremos que los
resultados muestre √∫nicamente las variables de ID, difgore, gorepre y
gorepst para ver la diferencia.

```{r, results = 'hide',  fig.show='hide'}
usagoredesc<-mutate(usa, difgore =  gorepst - gorepre) %>%
  arrange(., desc(gorepst)) %>%
  select(., id, difgore, gorepre, gorepst)
```

# View(usagoredesc), para corroborar que se agreg√≥ la variable

```{r, results = 'hide',  fig.show='hide'}
#de manera ascendente
usagoreasc <- mutate(usa, difgore =  gorepst - gorepre) %>%
  arrange(.,difgore) %>%
  select(., id, difgore, gorepre, gorepst)
```

#View(usagoreasc)

Vamos a poner gorepost como funci√≥n en arrange para ver su aprobaci√≥n
m√°s alta.

```{r, results = 'hide',  fig.show='hide'}
#diferencia m√°s alta
mutate(usa, difgore =  gorepst - gorepre) %>%
  arrange(., desc(difgore))  %>%
  select(., id, difgore, gorepre, gorepst)

```

### **TRANSMUTE**

Tambi√©n existe la funci√≥n transmute, que realiza lo mismo solo que
muestra √∫nicamente la nueva variable creada (no se agrega a la base de
datos)

Crearemos la vida variable de disfrencia pero con la aprobaci√≥n George
Bush

Vamos a cambiarla a num√©rica, para evitar que ocurra el mismo error.

```{r, results = 'hide',  fig.show='hide'}
usa$gbushpst<- as.numeric(usa$gbushpst)
usa$gbushpre<- as.numeric(usa$gbushpre)

usabush<-transmute(usa, difbush = gbushpst - gbushpre) %>%
  arrange(., desc(difbush))

```

#View(usabush)

### **group_by**: Agrupar datos

Agrupa diferentes observaciones de manera que el conjunto de datos
original no cambie.

Aca estamos indicando que se agrupe la data en base a posici√≥n pol√≠tica.

Finalmente, agruparemos datos y usaremos m√°s de una funci√≥n

En el primer ejemplo, lo que haremos es agrupar los datos mediante la
posici√≥n pol√≠tica, y usaremos sumarise para sacar el promedio de la
aprobaci√≥n de Bush post gesti√≥n Vemos los resultados. Vemos una
tendencia que los m√°s conservadores ten√≠an una aprobaci√≥n m√°s alta de
Bush

```{r, results = 'hide',  fig.show='hide'}
usa.g <- usa%>% 
  group_by(.,) %>% 
  summarise(mean = mean(gbushpst,na.rm=TRUE), n = n())
usa.g
```

Ahora con Al Gore ¬ølos datos se voltean no? Los encuestados que se
consideran muy Liberales, aprueban m√°s la gesti√≥n de AlGore, a
diferencia de los muy conservadores.

```{r, results = 'hide',  fig.show='hide'}
usa.b <- usa%>% 
  group_by(., consipol) %>% 
  summarise(mean = mean(gorepst,na.rm=TRUE), n = n())
usa.b
```

## **REPASO MODELO LINEAL GENERAL M√öLTIPLE**

Recordemos que con los modelos buscamos medir el efecto de un conjunto
de variables independientes sobre una dependiente y tambi√©n con el
modelo creado predecir.

En este modelo es indispensable contar con una variable dependiente
num√©rica continua.

Como se mencion√≥ en la clase anterior, para obtener el mejor modelo con
la recta que capte la mayor√≠a de las coordenadas, se realizaba el m√©todo
de los m√≠nimos cuadrados (el cual ya es calculado por R).

Como no todo es perfecto, para poder realiar este m√©todo, se tienen que
cumplir 5 supuestos, y as√≠ asegurar que el modelo que creemos sea
estable y pueda predecir correctamente.

Para poder repasar nuevamente los pasos de an√°lisis y los requisito
usaremos la base de datos de la clase pasada, que conten√≠a variables
sobre los casos de COVID a nivel regional, y otras variables
sociodemogr√°ficas, econ√≥micas etc.

## Regresi√≥n Lineal

### Ejemplo 1: Prediciendo los casos de COVID-19

Obtenemos nuestra base de datos:

```{r setup, results = 'hide',  fig.show='hide'}
library(rio)
competitividad<-import("COVID - COMPETITIVIDAD.sav")
names(competitividad)
```

### RECORDANDO LA REGRESI√ìN LINEAL

Calcularemos un modelo para predecir los casos de COVID-19 a partir del
gasto real por hogar mensual

Variable dependiente: Casos COVID-19 por cada 100 mil personas

Variable independiente: gasto real por hogar mensual (var5)

```{r, results = 'hide',  fig.show='hide'}
modelo <-lm(competitividad$casos_100k ~ competitividad$var5)
summary(modelo)
```

Seguimos nuestro flujograma para evaluar el modelo:

1.  Nos preguntamos si el modelo es v√°lido
2.  Qu√© tanto explica el modelo
3.  Si la variable independiente aporta al modelo
4.  Identificamos los coeficientes

¬øQu√© sucede si ahora agregamos m√°s variables?

Calculamos nuestro modelo, en este caso usaremos lo siguiente:

Variable dependiente: Casos COVID-19 por cada 100 mil personas Variables
independientes: Stock de capital por trabajador (var3) + gasto real por
hogar mensual (var5) + morbilidad (var20).

```{r, results = 'hide',  fig.show='hide'}
modelo1 <- lm(competitividad$casos_100k~ competitividad$var3+competitividad$var5+
                competitividad$var20)
summary(modelo1)
```

Seguimos nuestro flujograma para evaluar el modelo:

1.  Nos preguntamos si el modelo es v√°lido
2.  Qu√© tanto explica el modelo
3.  Si las variables independientes aportan al modelo
4.  Identificamos los coeficientes

```{r, results = 'hide',  fig.show='hide'}
modelo1$coefficients
```

5.  Construimos la ecuaci√≥n

------------------------------------------------------------------------
